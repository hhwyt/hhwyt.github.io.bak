---

layout: post
title:  "如何打乱一个数组"
categories: 算法
tags: 概率论

---

给一个数组 array，如何将数组中所有元素打乱？把数组看成一副扑克牌的话，这个问题就可以看成如何设计出一个洗牌的算法，保证洗出来的牌是均匀分布的。本文就来探究一下这个问题。



对于一个长度为 $n$ 的数组，有 $n!$ 种可能的排列。要想打乱数组，实际就是从 $n!$ 种排列中等概率的挑选出一种排列。假设被挑选出的排列为 $a_1, a_2...a_n $，用 $  P(a_1,a_2...a_n)$ 表示排列 $ a_1,a_2...a_n $ 被挑选出的概率，$P(a_i), 1 \leq i \leq n$ 表示位置 $i$ 上的元素 $a_i$ 被挑选出的概率，则有 $P(a_1,a_2...a_n) = \prod_{i=1}^n P(a_i)$  。也就是说要保证 $ P(a_1,a_2...a_n) $ 等概率，只需保证 $ P(a_i) $ 等概率即可。



#### 暴力算法

回忆一下概率论中的摸球不放回模型，总共有 $ n! $ 种可能的结果，并且摸到每个球的概率都是均等的，摸球生成的序列正好就是等概率的一个排列。我们可以借助这种思想来实现一个简单暴力的洗牌算法。

首先把数组 array 复制一份给数组 aux，之后每次随机从 aux 中取出一个数，为了防止数被重复取出，每次取完就把这个数从 aux 中移除。



##### 算法正确性证明

在 $ k = 1 $ 时，显然被选中的概率为 $\frac{1}{n} $ 。

当 $ k > 1 $ 时，$ P($元素 $ a_k$ 在第 $ k$ 轮被选中的概率$）$ = $P($元素 $a_k$ 在前 $k-1$ 轮不被选中的概率$ ) $ $\times P($元素 $ a_k $ 在第 $ k$ 轮被选中的概率 $)$。假设总共有 $ n $ 个元素，概率公式为：
$$
\begin{align}
P &= \frac{1}{n-k+1} \prod_{i=1}^{k-1}\frac{n-i}{n-i+1} \\
 &= \frac{1}{n-k+1}(\frac{n-1}{n}\frac{n-2}{n-1}\frac{n-3}{n-2}...\frac{n-k+1}{n-k+2}) \\
 &= \frac{1}{n}
\end{align}
$$
显然，对于任意的 $ k $，不论哪一轮被选中，概率都是 $ \frac{1}{n} $。



##### Time Complexity

$ O(n^2) $，需要生成长度为 $ n $ 的排列，且生成每一个元素的同时需要从原数组（或链表，取决于实现）删除该元素。

##### Space Complexity

$ O(1) $



#### Fisher-Yates 洗牌算法

暴力算法生成排列中每一个元素的同时需要从原数组中删除该元素，这个操作是线性的，可以优化。

下面介绍一下 Fisher-Yates 洗牌算法：

Fisher-Yates 算法思想跟暴力算法类似，但为了避免删除的线性操作，它将整个数组看成了已选中和待选两部分。初始状态下，所有元素都属于待选部分。第 $ 1$ 次从待选部分挑选出一个元素，将这个元素和下标 $0$ 的元素互换。下标 $0$  对应的元素就属于已选中部分。继续从待选部分挑选，选出的元素和下标 $1$ 对应元素交换，下标 $ 0, 1$ 对应的元素就都属于已选中部分，依次类推。位于已选中的部分中的元素不会再被选，这就模拟了摸球不放回的过程。用交换代替删除操作，时间复杂度瞬间降到了 $ O(1)$。



##### Time Complexity

$ O(n)$，生成长度为 $ n $ 的排列，生成每一个元素的同时不需要删除。

##### Space Complexity

$ O(1) $



#### 蓄水池算法

对于长度较短且固定的数组，Fisher-Yates 洗牌算法是渐进最优的一种算法。但如果数组长度 $ n $ 无限长，比如它是流式输入的一个序列，我们无法知道它的长度有多长，如何遍历一遍这个序列，从中抽样出 $ m $ 个元素，并且还是等概率的呢？这就引入了我们要说的蓄水池算法。



蓄水池算法需要先构造长度为 $m$ 的池子，对于第 $ k $ 个元素 $ a_k $ ：

1. 若 $ k \leq m $，$ a_k $ 直接放入池子中
2. 若 $ k > m $，则生成区间  $[1, k]$ 内的随机数 $ r $，若 $ r \leq m $，则 $ a_k $ 替换掉 $a_r$。重复执行步骤 $ 2 $，直到 $ k > n $ 算法终止。



##### 数学归纳法证明

初始状态下，前 $ m $ 个元素进入池子的概率都是 $ \frac{m}{m}=1$，显然是等概率的。

假设总共有 $ i $ 个元素，$ i > m $，每个元素进入池子的概率均为 $\frac{m}{i}$，我们要证明总共有 $i+1$ 个元素时，每个元素进入池子的概率均为 $ \frac{m}{i+1} $ 。



当总共有 $ i + 1 $ 个元素时，对于第 $ i+1 $ 个元素 $ a_{i+1} $，进入池子的概率显然是 $ \frac{m}{i+1} $。

对于前 $ j $ 个元素 $ a_j $，$ j \leq i $，$P(a_j$ 在第 $i+1$  轮在池中的概率$) $ $= P(a_j $ 在前 $ i$  轮已经进入池子的概率$)P(a_j$ 在第 $i+1$ 轮不被替换掉的概率$)  = \frac{m}{i} (P(a_{i+1} $ 没有进入池子的概率 $) + P(a_{i+1}$  进入池子但没有替换掉 $a_j$ 的概率) ) ，即：
$$
\begin{align}
P &=\frac{m}{i} (\frac{i+1-m}{i+1}) + (\frac{m}{i+1} \times \frac{m-1}{m}) \\
&= \frac{m}{i} (\frac{i+1-m}{i+1} + \frac{m-1}{i+1}) \\
&= \frac{m}{i} (\frac{i}{i+1}) \\
&= \frac{m}{i+1}
\end{align}
$$

由此可见，总共有 $ i + 1 $ 个元素时，也满足假设条件。命题得证。

##### Time Complexity

$ O(n) $

##### Space Complexity

$ O(m) $ 

